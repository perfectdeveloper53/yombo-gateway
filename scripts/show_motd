#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
A simple MOTD generator than can be used to update
"""
import argparse
from collections import OrderedDict
import configparser
from datetime import timedelta
import netifaces
import os
import platform
import subprocess
import re
import sys


class CN:
    """ Colors, normal"""
    BLACK = '\033[03m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    PURPLE = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    DONE = '\033[0m'


class CB:
    """ Colors, bold"""
    BLACK = '\033[03;1m'
    RED = '\033[31;1m'
    GREEN = '\033[32;1m'
    YELLOW = '\033[33;1m'
    BLUE = '\033[34;1m'
    PURPLE = '\033[35;1m'
    CYAN = '\033[36;1m'
    WHITE = '\033[37;1m'
    DONE = '\033[0m'


class CBU:
    """ Colors, bold"""
    BLACK = '\033[03;1;4m'
    RED = '\033[31;1;4m'
    GREEN = '\033[32;1;4m'
    YELLOW = '\033[33;1;4m'
    BLUE = '\033[34;1;4m'
    PURPLE = '\033[35;1;4m'
    CYAN = '\033[36;1;4m'
    WHITE = '\033[37;1;4m'
    DONE = '\033[0m'

parser = argparse.ArgumentParser()
parser.add_argument('-w', nargs='?', help='Set working directory')
args = parser.parse_args()

if args.w is None:
    data_path = "%s/.yombo" % os.path.expanduser("~")
else:
    data_path = args.w
data_path_exists = os.path.isdir(data_path)

program_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

sys.path.append(program_path)
import yombo.constants as constants
git_hash = subprocess.check_output(["git", "-C", program_path, "rev-parse", "--short", "HEAD"]).strip()
git_branch = subprocess.check_output(["git", "-C", program_path, "rev-parse", "--abbrev-ref", "HEAD"]).strip()

yombo_version = "%s -- %s:%s" % (constants.VERSION, git_branch.decode("utf-8"), git_hash.decode("utf-8"))

internal_hostname = 'localhost'
interfaces = netifaces.interfaces()
for i in interfaces:
    if i == 'lo' or i.startswith('vir'):
        continue
    iface = netifaces.ifaddresses(i).get(netifaces.AF_INET)
    if iface != None:
        internal_hostname = str(iface[0]['addr'])
        break

yombo_ini = 'Not configured'
if data_path_exists is True:
    try:
        config_parser = configparser.ConfigParser()
        config_parser.read('%s/yombo.ini' % data_path)
        yombo_ini = "Valid"
        dns_fqdn = config_parser.get('dns', 'fqdn', fallback="None")
        internal_ip = config_parser.get('core', 'localipaddress_v4', fallback=internal_hostname)
        external_ip = config_parser.get('core', 'externalipaddress_v4', fallback="None")
        nonsecure_port = config_parser.get('webinterface', 'nonsecure_port', fallback=8080)
        secure_port = config_parser.get('webinterface', 'secure_port', fallback=8443)
        auth_pin_required = config_parser.get('webinterface', 'auth_pin_required', fallback=False)
        auth_pin_type = config_parser.get('webinterface', 'auth_pin_type', fallback='')
        auth_pin = config_parser.get('webinterface', 'auth_pin', fallback='')
    except IOError as e:
        pass
    except configparser.NoSectionError:
        pass
else:
    dns_fqdn = "None"
    internal_ip = internal_hostname
    external_ip = "None"
    nonsecure_port = 8080
    secure_port = 8443
    auth_pin_required = False
    auth_pin_type = ''
    auth_pin = ''

if dns_fqdn != "None":
    local = "http://127.0.0.1:%s" % nonsecure_port
    internal = "http://i.%s:%s" % (dns_fqdn, nonsecure_port)
    external = "https://e.%s:%s" % (dns_fqdn, secure_port)
    globaluri = "http://%s" % dns_fqdn
else:
    local = "http://127.0.0.1:%s" % nonsecure_port
    internal = "http://%s:%s" % (internal_ip, nonsecure_port)
    external = "Not available"
    globaluri = "Not available"

data_yombo = OrderedDict()
data_system = OrderedDict()
data_system['Hostname'] = str(platform.node())
data_yombo['yombo.ini'] = yombo_ini
data_yombo['Yombo Version'] = yombo_version
data_yombo['FQDN'] = dns_fqdn
data_yombo['From anywhere'] = globaluri
data_yombo['Local'] = local
data_yombo['Internal'] = internal
data_yombo['External'] = external

if auth_pin_required in (True, 'true', 'True'):
    if auth_pin_type == 'pin':
        data_yombo['Auth pin'] = auth_pin
    else:
        data_yombo['Auth pin'] = 'Using TOPT, unable to display'
else:
    data_yombo['Auth pin'] = 'None required'

with open('/proc/uptime', 'r') as f:
    uptime_seconds = float(f.readline().split()[0])
    uptime = timedelta(seconds = uptime_seconds)
data_system['Uptime'] = "%s days, %s hours" % (uptime.days, uptime.seconds//3600)
data_system['Kernel'] = platform.release()

command = "cat /proc/cpuinfo"
all_info = subprocess.check_output(command, shell=True).strip()
cpu_model = "Unknown"
for line in all_info.split(b"\n"):
    if b"model name" in line:
        cpu_model = re.sub(b".*model name.*:", b"", line, 1).decode("utf-8").strip()
        break
data_system['CPU'] = cpu_model

if data_path_exists is True:
    df = subprocess.Popen(["df", "-h", data_path], stdout=subprocess.PIPE)
    output = df.communicate()[0].decode("utf-8")
    device, size, used, available, percent, mountpoint = \
        output.split("\n")[1].split()
    data_system['Disk'] = "%s / %s" % (used, available)
else:
    data_system['Disk'] = "Data directory not found"

# Now convert the dict to a list.
data_formatted = [
    '',
    '',
    '%sYombo Access URLS and details%s' % (CBU.WHITE, CB.DONE),
]
for key, value in data_yombo.items():
    data_formatted.append("%s%s%s: %s" % (CB.RED, key, CB.DONE, value))

data_formatted.append('')
data_formatted.append('%sSystem details%s' % (CBU.WHITE, CB.DONE))
for key, value in data_system.items():
    data_formatted.append("%s%s%s: %s" % (CB.RED, key, CB.DONE, value))

logo = [
'%sYombo Gateway%s Learn more at: https://yombo.net' % (CB.BLUE, CB.DONE),
'                      ',
' YYYYYYY       YYYYYYY',
' Y:::::Y       Y:::::Y',
' Y:::::Y       Y:::::Y',
' Y::::::Y     Y::::::Y',
' YYY:::::Y   Y:::::YYY',
'    Y:::::Y Y:::::Y   ',
'     Y:::::Y:::::Y    ',
'      Y:::::::::Y     ',
'       Y:::::::Y      ',
'        Y:::::Y       ',
'        Y:::::Y       ',
'        Y:::::Y       ',
'        Y:::::Y       ',
'     YYYY:::::YYYY    ',
'     Y:::::::::::Y    ',
'     YYYYYYYYYYYYY    ',
]

for logo_idx, logo_elem in enumerate(logo):
    try:
        print("%s  %s" % (logo_elem, data_formatted[logo_idx]))
    except IndexError:
        print("%s" % logo_elem)

